# Booleans

True
False

==>

Program(Boolean, Boolean)

# Identifiers

one
Two_Three

==>

Program(Identifier, Identifier)

# Strings

"hello"
"one\"\\two"

==>

Program(String, String)

# Applications

(println "Hello World")

==>

Program(ParameterSection("(",Parameter(Identifier,⚠(String)),")"))

# Application with multiple arguments

(map f [1, 2, 3])

==>

Program(ParameterSection("(",Parameter(Identifier,⚠,Type(Identifier)),⚠,⚠(Number),⚠(Number),⚠(Number),")"))

# Nested application

(f x y)

==>

Program(ParameterSection("(",Parameter(Identifier,⚠,Type(Identifier)),⚠(Identifier),")"))

# Boolean operators

True && False

==>

Program(BinaryOperation(LValue(Boolean),BooleanOperator,RValue(Boolean)))

# Comparison operator

1 == 1

==>

Program(BinaryOperation(LValue(Number),ComparisonOperator,RValue(Number)))

# Arithmetic operator

2 + 3

==>

Program(BinaryOperation(LValue(Number),ArithmeticOperator,RValue(Number)))

# Simple definiton

let abc = 123

==>

Program(Definition(let,LValue(Identifier),AssignmentOperator,RValue(Number)))

# Definiton with parameters

let mul (x: Int, y: Int) = x * y

==>

Program(Definition(let,LValue(Identifier),ParameterSection("(",Parameter(Identifier,Type(Identifier)),Parameter(Identifier,Type(Identifier)),")"),AssignmentOperator,RValue(BinaryOperation(LValue(Identifier),ArithmeticOperator,RValue(Identifier)))))

# Definiton with parameters and return value

let mul (x: Int, y: Int) => Int = x * y

==>

Program(Definition(let,LValue(Identifier),ParameterSection("(",Parameter(Identifier,Type(Identifier)),Parameter(Identifier,Type(Identifier)),")"),ReturnValue(Type(Identifier)),AssignmentOperator,RValue(BinaryOperation(LValue(Identifier),ArithmeticOperator,RValue(Identifier)))))

# Hello World

let main = do
  (println "Hello World")
end

==>

Program(Definition(let,LValue(Identifier),AssignmentOperator,RValue(DoBlock(do,ParameterSection("(",Parameter(Identifier,⚠(String)),")"),end))))

# If

if a == b then
  1
else
  2
end

==>

Program(If(if,BinaryOperation(LValue(Identifier),ComparisonOperator,RValue(Identifier)),then,Number,else,Number,end))

# Struct

struct Person = (name: String)

==>

Program(Struct(struct,Identifier,AssignmentOperator,ParameterSection("(",Parameter(Identifier,Type(Identifier)),")")))

# Trait

trait Show = do
  show :: Self -> String
end

==>

Program(Trait(trait,Identifier,AssignmentOperator,DoBlock(do,HaskellStyle(Identifier,Identifier,Identifier),end)))

# Do block

do
  (println "Hello World")
end

==>

Program(DoBlock(do,ParameterSection("(",Parameter(Identifier,⚠(String)),")"),end))

# Impl

impl Show for Person = do
  show = "Person"
end

==>

Program(Impl(impl,Identifier,for,Identifier,AssignmentOperator,DoBlock(do,BinaryOperation(LValue(Identifier),AssignmentOperator,RValue(String)),end)))

# Cast

12 as String

==>

Program(Cast(LValue(Number),as,Type(Identifier)))

# Struct is/satisfies

struct Teacher = (name: String) is Person, Employee satisfies (it < 4)

==>

Program(Struct(struct,Identifier,AssignmentOperator,ParameterSection("(",Parameter(Identifier,Type(Identifier)),")"),is,Type(Identifier),Type(Identifier),satisfies,"(",BinaryOperation(LValue(Identifier),ComparisonOperator,RValue(Number)),")"))

# Multiline comment

/* test comment */

let x = 5

==>

Program(BlockComment,Definition(let,LValue(Identifier),AssignmentOperator,RValue(Number)))

# Multiline comment spanning multiple lines

/* test 

*   multi line

*   comments

*/

let y = 10

==>

Program(BlockComment,Definition(let,LValue(Identifier),AssignmentOperator,RValue(Number)))

# When with literal patterns

when x of
  1 -> 5
  2 -> 6
  else -> 7
end

==>

Program(When(when,Identifier,of,WhenCase(Pattern(LValue(Number)),Number),WhenCase(Pattern(LValue(Number)),Number),else,Number,end))

# When with boolean patterns

when b of
  True -> 1
  False -> 2
  else -> 3
end

==>

Program(When(when,Identifier,of,WhenCase(Pattern(LValue(Boolean)),Number),WhenCase(Pattern(LValue(Boolean)),Number),else,Number,end))

# When with empty list pattern

when list of
  [] -> 1
  else -> 2
end

==>

Program(When(when,Identifier,of,WhenCase(Pattern(EmptyList),Number),else,Number,end))

# When with list patterns

when list of
  [x] -> 1
  [x, y] -> 2
  (x:y:rest) -> 3
  else -> 4
end

==>

Program(When(when,Identifier,of,WhenCase(Pattern(SingleElementList(Identifier)),Number),WhenCase(Pattern(TwoElementList(Identifier,Identifier)),Number),WhenCase(Pattern(ConsPattern("(",Identifier,Identifier,Identifier,")")),Number),else,Number,end))

# When with character list pattern

when str of
  ['h', 'e', 'l', 'l', 'o'] -> 1
  (c:rest) -> 2
  else -> 3
end

==>

Program(When(when,Identifier,of,WhenCase(Pattern(CharListPattern(CharLiteral,CharLiteral,CharLiteral,CharLiteral,CharLiteral)),Number),WhenCase(Pattern(ConsPattern("(",Identifier,Identifier,")")),Number),else,Number,end))

# List literals

[]

==>

Program(⚠)

# List literal with elements

[1, 2, 3]

==>

Program(⚠,Number,⚠,Number,⚠,Number,⚠)

# List literal with mixed types

["hello", 42, True]

==>

Program(⚠,String,⚠,Number,⚠,Boolean,⚠)

# Lambda function

\x -> x + 1

==>

Program(⚠,BinaryOperation(LValue(Identifier),ArithmeticOperator,⚠(ComparisonOperator),RValue(BinaryOperation(LValue(Identifier),ArithmeticOperator,RValue(Number)))))

# Lambda with multiple parameters

\(x: Int, y: Int) -> x + y

==>

Program(⚠,ParameterSection("(",Parameter(Identifier,Type(Identifier)),Parameter(Identifier,Type(Identifier)),")"),⚠(ArithmeticOperator),⚠(ComparisonOperator),BinaryOperation(LValue(Identifier),ArithmeticOperator,RValue(Identifier)))

# Generic types

List<Int>

==>

Program(BinaryOperation(LValue(Identifier),ComparisonOperator,RValue(BinaryOperation(LValue(Identifier),ComparisonOperator,⚠))))

# Nested generic types

Maybe<List<String>>

==>

Program(BinaryOperation(LValue(Identifier),ComparisonOperator,RValue(BinaryOperation(LValue(Identifier),ComparisonOperator,RValue(BinaryOperation(LValue(Identifier),ComparisonOperator,⚠(ComparisonOperator)))))))

# Import statement

import Data.List

==>

Program(Identifier,Identifier,⚠,Identifier)

# Qualified import

qualified import Data.List

==>

Program(Identifier,Identifier,Identifier,⚠,Identifier)

# Import with alias

import Data.List as L

==>

Program(Identifier,Identifier,⚠,Cast(LValue(Identifier),as,Type(Identifier)))

# Qualified import with alias

qualified import Data.List as L

==>

Program(Identifier,Identifier,Identifier,⚠,Cast(LValue(Identifier),as,Type(Identifier)))
