# Booleans

True
False

==>

Program(BaseExpression(Boolean), BaseExpression(Boolean))

# Identifiers

one
Two_Three

==>

Program(BaseExpression(Identifier), BaseExpression(Identifier))

# Strings

"hello"
"one\"\\two"

==>

Program(BaseExpression(String), BaseExpression(String))

# Boolean operators

True && False

==>

Program(BinaryOperation(LValue(Boolean),BooleanOperator,RValue(BaseExpression(Boolean))))

# Comparison operator

1 == 1

==>

Program(BinaryOperation(LValue(Number),ComparisonOperator,RValue(BaseExpression(Number))))

# Arithmetic operator

2 + 3

==>

Program(BinaryOperation(LValue(Number),ArithmeticOperator,RValue(BaseExpression(Number))))

# Simple definiton

let abc = 123

==>

Program(Definition(let,LValue(Identifier),AssignmentOperator,RValue(BaseExpression(Number))))

# Definiton with parameters

let mul (x: Int, y: Int) = x * y

==>

Program(Definition(let,LValue(Identifier),ParameterSection("(",Parameter(Identifier,":",Type(Identifier)),Parameter(Identifier,":",Type(Identifier)),")"),AssignmentOperator,RValue(BinaryOperation(LValue(Identifier),ArithmeticOperator,RValue(BaseExpression(Identifier))))))

# Definiton with parameters and return value

let mul (x: Int, y: Int) => Int = x * y

==>

Program(Definition(let,LValue(Identifier),ParameterSection("(",Parameter(Identifier,":",Type(Identifier)),Parameter(Identifier,":",Type(Identifier)),")"),ReturnValue("=>",Type(Identifier)),AssignmentOperator,RValue(BinaryOperation(LValue(Identifier),ArithmeticOperator,RValue(BaseExpression(Identifier))))))

# If

if a == b then
  1
else
  2
end

==>

Program(If(if,BinaryOperation(LValue(Identifier),ComparisonOperator,RValue(BaseExpression(Identifier))),then,BaseExpression(Number),else,BaseExpression(Number),end))

# Struct

struct Person = (name: String)

==>

Program(Struct(struct,Identifier,AssignmentOperator,ParameterSection("(",Parameter(Identifier,":",Type(Identifier)),")")))

# Trait

trait Show = do
  show :: Self -> String
end

==>

Program(Trait(trait,Identifier,AssignmentOperator,DoBlock(do,HaskellStyle(Identifier,"::",Identifier,"->",Identifier),end)))

# Do block

do
  let x = 5
end

==>

Program(DoBlock(do,Definition(let,LValue(Identifier),AssignmentOperator,RValue(BaseExpression(Number))),end))

# Impl

impl Show for Person = do
  show = "Person"
end

==>

Program(Impl(impl,Identifier,for,Identifier,AssignmentOperator,DoBlock(do,BinaryOperation(LValue(Identifier),AssignmentOperator,RValue(BaseExpression(String))),end)))

# Cast

12 as String

==>

Program(Cast(LValue(Number),as,Type(Identifier)))

# Struct is

struct Teacher = (name: String) is Person

==>

Program(Struct(struct,Identifier,AssignmentOperator,ParameterSection("(",Parameter(Identifier,":",Type(Identifier)),")"),is,Type(Identifier)))

# Multiline comment

/* test comment */

let x = 5

==>

Program(BlockComment,Definition(let,LValue(Identifier),AssignmentOperator,RValue(BaseExpression(Number))))

# When with literal patterns

when x of
  1 -> 5
  2 -> 6
  else -> 7
end

==>

Program(When(when,BaseExpression(Identifier),of,WhenCase(Pattern(LValue(Number)),"->",BaseExpression(Number)),WhenCase(Pattern(LValue(Number)),"->",BaseExpression(Number)),else,"->",BaseExpression(Number),end))

# When with boolean patterns

when b of
  True -> 1
  False -> 2
  else -> 3
end

==>

Program(When(when,BaseExpression(Identifier),of,WhenCase(Pattern(LValue(Boolean)),"->",BaseExpression(Number)),WhenCase(Pattern(LValue(Boolean)),"->",BaseExpression(Number)),else,"->",BaseExpression(Number),end))

# When with empty list pattern

when list of
  [] -> 1
  else -> 2
end

==>

Program(When(when,BaseExpression(Identifier),of,WhenCase(Pattern(EmptyList),"->",BaseExpression(Number)),else,"->",BaseExpression(Number),end))

# List literals non-empty

[42]

==>

Program(BaseExpression(ListLiteral("[",BaseExpression(Number),"]")))

# List literal with elements

[1, 2, 3]

==>

Program(BaseExpression(ListLiteral("[",BaseExpression(Number),BaseExpression(Number),BaseExpression(Number),"]")))

# List literal with mixed types

["hello", 42, True]

==>

Program(BaseExpression(ListLiteral("[",BaseExpression(String),BaseExpression(Number),BaseExpression(Boolean),"]")))

# Lambda function

\x -> x + 1

==>

Program(Lambda(LambdaStart,Identifier,"->",BinaryOperation(LValue(Identifier),ArithmeticOperator,RValue(BaseExpression(Number)))))

# Lambda with multiple parameters

\(x: Int, y: Int) -> x + y

==>

Program(Lambda(LambdaStart,ParameterSection("(",Parameter(Identifier,":",Type(Identifier)),Parameter(Identifier,":",Type(Identifier)),")"),"->",BinaryOperation(LValue(Identifier),ArithmeticOperator,RValue(BaseExpression(Identifier)))))

# Import statement

import MyModule

==>

Program(Import(import,ImportPath(Identifier)))

# Qualified import

qualified import MyModule

==>

Program(Import(qualified,import,ImportPath(Identifier)))

# Import with alias

import MyModule as M

==>

Program(Import(import,ImportPath(Identifier),as,Identifier))

# Qualified import with alias

qualified import MyModule as M

==>

Program(Import(qualified,import,ImportPath(Identifier),as,Identifier))

# Import with from

import Data from Prelude

==>

Program(Import(import,ImportPath(Identifier),from,ImportPath(Identifier)))

# Floating point numbers

3.14
1.0

==>

Program(BaseExpression(Float),BaseExpression(Float))

# String concatenation

"hello" ++ "world"

==>

Program(BinaryOperation(LValue(String),StringConcatOperator,RValue(BaseExpression(String))))

# Value struct

value struct PositiveInt = (num: Int)

==>

Program(ValueStruct(value,struct,Identifier,AssignmentOperator,ParameterSection("(",Parameter(Identifier,":",Type(Identifier)),")")))

# Value struct with is

value struct EvenNumber = (num: Int) is Number

==>

Program(ValueStruct(value,struct,Identifier,AssignmentOperator,ParameterSection("(",Parameter(Identifier,":",Type(Identifier)),")"),is,Type(Identifier)))

# External block

external "__default" = do
  puts :: String -> IO
end

==>

Program(External(external,String,AssignmentOperator,DoBlock(do,HaskellStyle(Identifier,"::",Identifier,"->",Identifier),end)))

# Struct instantiation

Person{name: "Alice", age: 30}

==>

Program(StructInstantiation(Identifier,"{",StructField(Identifier,":",BaseExpression(String)),StructField(Identifier,":",BaseExpression(Number)),"}"))

# Field access

person.name
peter.age

==>

Program(FieldAccess(Identifier,".",Identifier),FieldAccess(Identifier,".",Identifier))

# Chained field access

person.address.street

==>

Program(FieldAccess(FieldAccess(Identifier,".",Identifier),".",Identifier))

# Module declaration

module MyModule

let x = 5

==>

Program(Module(module,Identifier),Definition(let,LValue(Identifier),AssignmentOperator,RValue(BaseExpression(Number))))

