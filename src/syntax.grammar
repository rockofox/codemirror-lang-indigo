@top Program { (Import | expression)* }

@skip { space | LineComment | BlockComment }

commaSep<content> { "" | content ("," content)* }
commaSep1<content> { content ("," content)* }
arrowSep<content> { content ("->" content)* }
parenthesized<content> { "(" content ")" }
kw<term> { @specialize[@name={term}]<Identifier, term> }

expression {
  Application |
  BinaryOperation {
    LValue
    (ArithmeticOperator | ComparisonOperator | BooleanOperator | AssignmentOperator)
    RValue
  } |
  Definition {
    kw<"let"> LValue ParameterSection? ReturnValue? AssignmentOperator RValue
  } |
  If |
  When |
  Struct |
  Trait |
  Impl |
  HaskellStyle |
  Lambda |
  Cast |
  DoBlock |
  ListLiteral |
  BaseExpression
}

Application {
  BaseExpression (BaseExpression | parenthesized<expression> | ListLiteral | String | Boolean | Number)+
}

BaseExpression {
  parenthesized<expression> |
  Identifier |
  String |
  Boolean |
  Number |
  ListLiteral
}

ReturnValue {
  "=>" Type
}

ParameterSection {
  "(" Parameter ("," Parameter)* ")" |
  "(" ")"
}

Type {
  GenericType {
    Identifier "<" commaSep<Type> ">"
  } |
  Identifier
}

Parameter {
  Identifier ":" Type
}

LValue {
  Identifier | String | Boolean | Number
}

RValue {
  expression
}
DoBlock {
  kw<"do"> expression* kw<"end">
}

If {
  kw<"if"> expression kw<"then"> expression kw<"else"> expression kw<"end">
}

When {
  kw<"when"> expression kw<"of"> WhenCase* (kw<"else"> "->" expression)? kw<"end">
}

WhenCase {
  Pattern "->" expression
}

Pattern {
  EmptyList |
  SingleElementList |
  TwoElementList |
  ConsPattern |
  CharListPattern |
  LValue
}

EmptyList {
  "[]"
}

SingleElementList {
  "[" Identifier "]"
}

TwoElementList {
  "[" Identifier "," Identifier "]"
}

ConsPattern {
  "(" Identifier (":" Identifier)+ ")"
}

CharListPattern {
  "[" commaSep<CharLiteral> "]"
}

@precedence { is @left, satisfies @left }
Struct {
    kw<"struct"> Identifier AssignmentOperator ParameterSection (!is isSection)? (!satisfies satisfiesSection)?
}

isSection {
    kw<"is"> Type ("," Type)*
}

satisfiesSection {
    kw<"satisfies"> parenthesized<expression>
}

Trait {
  kw<"trait"> Identifier AssignmentOperator expression
}

Impl {
  kw<"impl"> Identifier kw<"for"> Identifier AssignmentOperator expression
}

HaskellStyle {
  Identifier "::" arrowSep<Identifier> // AssignmentOperator expression
}

Cast {
  LValue kw<"as"> Type
}

Lambda {
  LambdaStart ParameterSection "->" expression |
  LambdaStart Identifier "->" expression
}

ListLiteral {
  "[" commaSep<expression> "]"
}

Import {
  (kw<"qualified">)? kw<"import"> Identifier (kw<"as"> Identifier)?
}

@tokens {
  identifierChar { @asciiLetter | $[_$\u{a1}-\u{10ffff}] }
  word { identifierChar (identifierChar | @digit)* }
  Identifier { word }
  String { '"' (!["\\] | "\\" _)* '"' }
  CharLiteral { "'" (!['\\] | "\\" _)* "'" }
  Boolean { "True" | "False" }
  LineComment { "#" ![\n]* }
  BlockComment { "/*" (![@*] | "*" ![@/])* "*/" }
  AssignmentOperator { "=" }
  ArithmeticOperator { "+" | "-" | "*" | "/" | "%" }
  ComparisonOperator { "==" | "!=" | "<=" | ">=" }
  BooleanOperator { "&&" | "||" }
  Number { $[0-9]+ }
  LambdaStart { "\\" }
  space { $[ \t\n\r]+ }

  "(" ")" "[" "]" "<" ">"
  @precedence { ArithmeticOperator, ComparisonOperator, BooleanOperator, AssignmentOperator, Boolean, Identifier, "<", ">" }
}

@detectDelim
