@top Program { (Import | expression)* }

@skip { space | LineComment | BlockComment }

commaSep<content> { "" | content ("," content)* }
arrowSep<content> { content ("->" content)* }
parenthesized<content> { "(" content ")" }
kw<term> { @specialize[@name={term}]<Identifier, term> }

expression {
  BinaryOperation {
    LValue
    (ArithmeticOperator | ComparisonOperator | BooleanOperator | StringConcatOperator | AssignmentOperator)
    RValue
  } |
  Definition {
    kw<"let"> LValue ParameterSection? ReturnValue? AssignmentOperator RValue
  } |
  If |
  When |
  ValueStruct |
  Struct |
  Trait |
  Impl |
  External |
  HaskellStyle |
  Lambda |
  Cast |
  DoBlock |
  StructInstantiation |
  FieldAccess |
  BaseExpression
}

BaseExpression {
  parenthesized<expression> |
  Identifier |
  String |
  Boolean |
  Number |
  Float |
  ListLiteral
}

ReturnValue {
  "=>" Type
}

ParameterSection {
  "(" Parameter ("," Parameter)* ")" |
  "(" ")"
}

Type {
  ListType {
    kw<"List"> "{" Type "}"
  } |
  GenericType {
    Identifier "<" commaSep<Type> ">"
  } |
  Identifier
}

Parameter {
  Identifier ":" Type
}

LValue {
  Identifier | String | Boolean | Number | Float | FieldAccess
}

RValue {
  expression
}
DoBlock {
  kw<"do"> expression* kw<"end">
}

If {
  kw<"if"> expression kw<"then"> expression kw<"else"> expression kw<"end">
}

When {
  kw<"when"> expression kw<"of"> WhenCase* (kw<"else"> "->" expression)? kw<"end">
}

WhenCase {
  Pattern "->" expression
}

Pattern {
  EmptyList |
  SingleElementList |
  TwoElementList |
  ConsPattern |
  CharListPattern |
  LValue
}

EmptyList {
  "[]"
}

SingleElementList {
  "[" Identifier "]"
}

TwoElementList {
  "[" Identifier "," Identifier "]"
}

ConsPattern {
  "(" Identifier (":" Identifier)+ ")"
}

CharListPattern {
  "[" commaSep<CharLiteral> "]"
}

@precedence { is @left, satisfies @left }
ValueStruct {
    kw<"value"> kw<"struct"> Identifier AssignmentOperator ParameterSection (!is isTypes)? (!satisfies satisfiesSection)?
}

Struct {
    kw<"struct"> Identifier AssignmentOperator ParameterSection (!is isTypes)? (!satisfies satisfiesSection)?
}

isTypes {
    kw<"is"> Type
}

satisfiesSection {
    kw<"satisfies"> parenthesized<expression>
}

Trait {
  kw<"trait"> Identifier AssignmentOperator expression
}

Impl {
  kw<"impl"> Identifier kw<"for"> Identifier AssignmentOperator expression
}

External {
  kw<"external"> String AssignmentOperator DoBlock
}

StructInstantiation {
  Identifier "{" commaSep<StructField> "}"
}

StructField {
  Identifier ":" expression
}

FieldAccess {
  (Identifier | FieldAccess) "." Identifier
}

HaskellStyle {
  Identifier "::" arrowSep<Identifier> // AssignmentOperator expression
}

Cast {
  LValue kw<"as"> Type
}

Lambda {
  LambdaStart ParameterSection "->" expression |
  LambdaStart Identifier "->" expression
}

ListLiteral {
  "[" commaSep<expression> "]"
}

Import {
  (kw<"qualified">)? kw<"import"> Identifier (kw<"from"> Identifier)? (kw<"as"> Identifier)?
}

@tokens {
  identifierChar { @asciiLetter | $[_$\u{a1}-\u{10ffff}] }
  word { identifierChar (identifierChar | @digit)* }
  Identifier { word }
  String { '"' (!["\\] | "\\" _)* '"' }
  CharLiteral { "'" (!['\\] | "\\" _)* "'" }
  Boolean { "True" | "False" }
  LineComment { "#" ![\n]* }
  BlockComment { "/*" (![@*] | "*" ![@/])* "*/" }
  AssignmentOperator { "=" }
  StringConcatOperator { "++" }
  ArithmeticOperator { "+" | "-" | "*" | "/" | "%" }
  ComparisonOperator { "==" | "!=" | "<=" | ">=" | "<" | ">" }
  BooleanOperator { "&&" | "||" }
  Float { $[0-9]+ "." $[0-9]+ }
  Number { $[0-9]+ }
  LambdaStart { "\\" }
  space { $[ \t\n\r]+ }

  "(" ")" "[" "]" "<" ">" "{" "}" "." ":" "::" "->" "=>"
  @precedence { Float, Number, StringConcatOperator, ArithmeticOperator, ComparisonOperator, BooleanOperator, AssignmentOperator, Boolean, Identifier, "<", ">" }
}

@detectDelim
